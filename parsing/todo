
=================================
            TODAY :
=================================

--> TO COMMIT :

        // None
        // FIXED args handling : 
                // echo $ $$ $'' $"" "$USER" '$USER' $'USER' $"USER" $dhfgh $USER $'sdgdh' $"dgdfh"

--> TO DO :

        // [ ] norm + refactor + drw scheema
                // [x] tokenization 
                // [ ] quotes 
                // [x] expanding 
                        // if red before dont expand
                // [ ] syntax
                        // [ ] syntax error ; modify messages
                        // NOTE : ls | opens promt for next cmd , we dont have to handle it
                // [ ] redirections 
                        // [x] redirections after and before cmd
                        # < Makefile cat > out1 > out2 | ls > out3 > out4
                        # FIXED heredoc get stuck in infinite loop
                        // [ ] Expand in herdoc if delimiter is not literal:
                                # search and expand , ndup join + join 
                                FIXED << "$PWD" cat => should not expand inside
                // [ ] args handling 

                // FIXED << l see if it hangs because of tokenization logic 

=================================
            LATER :
=================================

// [ ] Exit status $?
// [ ] signals
// [ ] redirections by command if fails stop and move to next command


=================================
            UTILS :
=================================

// [x] handle heredoc
        // .heredoc file > if exists join the name with an incremented i = 1 to change the name 
        // work with 2 files one we read from and the second we return (points at the begining).
        // open readline and return the file when the delimiter is encountered
        //  pass it as an infile to the command.


// printf(">>> curr -%s- type: %d\n", curr->value, curr->type);
// printf(">>> tmp -%s- type: %d in: %d   out: %d\n", tmp->value, tmp->type, tmp->infile, tmp->outfile);

=================================
            TESTS :
=================================

echo "" "" 

echo "ls" "-la" 

echo "ls"'-la'

echo "'$USER'"

L""S"" 

l""s 

export cmd="ls    -la"  then: $cmd or echo $cmd or echo "$cmd"

export cmd="ls    -la"  then: export cmd2="$cmd" and then $cmd2

export cmd="[tab]ls [tab] -la  "

"abcd"$PWD'ff'

// < ./parsing/todo cmd arg1 arg2 | cmd2 arg1 arg2 > out1 > out2 


echo $dhfgh $USER


MINISHELL$ (())
command not found: (())
MINISHELL$ .
command not found: .
MINISHELL$ /
command not found: /


unset for many variables

$- bash-3.2$ export aa=+=
   bash-3.2$ export $aa=ls
   bash: export: `+==ls': not a valid identifier
   bash-3.2$ export a=oussmaa
   bash-3.2$ export $a=ls
   bash-3.2$ $oussmaa
   9a2o            README.md       main.c          minishell.h
   I-,1o           TODO            main.o          parsing
   Makefile        execution       minishell
   bash-3.2$ export
   declare -x OLDPWD
   declare -x PWD="/Users/olamrabt/Desktop/1337-MiniShell"
   declare -x SHLVL="1"
   declare -x a="oussmaa"
   declare -x aa="+="
   declare -x oussmaa="ls"